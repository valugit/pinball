<!DOCTYPE html>
<html lang="en">

<head>
  <title>WebGL - Projet - Cours 29/06/2020</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    html,
    body {
      margin: 0px;
      padding: 0px;
    }
    #c {
      background: url('images/arcade.jpg') no-repeat center center;
      background-size: cover;
    }
  </style>
  <script src="https://threejs.org/build/three.js"></script>
  <script type="text/javascript" src="../physi.js"></script>
</head>

<body>
    <canvas id="c"></canvas>
    <audio style="display:none" id="audio">

    <source src="images/hit.mp3" type="audio/mp3"></audio>
  <script type="text/javascript">
    'use strict';

    Physijs.scripts.worker = '../physijs_worker.js';
    Physijs.scripts.ammo = 'examples/js/ammo.js';


    let wWidth = window.innerWidth
    let wHeight = window.innerHeight

    const canvas = document.querySelector('#c')
    const renderer = new THREE.WebGLRenderer({
      canvas,
      alpha: true,
      antialias: true
    })
    renderer.setSize(wWidth, wHeight)

    let scene = new Physijs.Scene()

    // Loader
    let loader = new THREE.TextureLoader();

    // Materials
    let woodMaterial = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({ map: loader.load( 'images/wood.jpg' ) }),
        .3, // low friction
        .9 // high restitution
    );
    let glitterMaterial = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({ map: loader.load( 'images/glitter.jpg' ) }),
        .3, // low friction
        .9 // high restitution
    );
    let dark_woodMaterial = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({ map: loader.load( 'images/dark_wood.jpg' ) }),
        .3, // low friction
        .9 // high restitution
    );
    let silverMaterial = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({ map: loader.load( 'images/silver.jpg' ) }),
        .3, // low friction
        .9 // high restitution
    );

    // Background
    let backgroundGeometry = new THREE.CubeGeometry(230, 300, 100)
    let background = new Physijs.BoxMesh(backgroundGeometry, woodMaterial, 0, 0)
    background.position.set(15, 0, -25)
    background.name = 'background'
    background.receiveShadow = true;

    // Top Border
    let topBorderGeometry = new THREE.CubeGeometry(240, 10, 50)
    let topBorder = new Physijs.BoxMesh(topBorderGeometry, dark_woodMaterial, 0)
    topBorder.position.set(15, 150, 50)
    scene.add(topBorder)
    // Left Border
    let leftBorderGeometry = new THREE.CubeGeometry(10, 300, 50)
    let leftBorder = new Physijs.BoxMesh(leftBorderGeometry, dark_woodMaterial, 0)
    leftBorder.position.set(-100, 0, 50)
    scene.add(leftBorder)
    // Right Border
    let rightBorderGeometry = new THREE.CubeGeometry(10, 300, 50)
    let rightBorder = new Physijs.BoxMesh(rightBorderGeometry, dark_woodMaterial, 0)
    rightBorder.position.set(130, 0, 50)
    scene.add(rightBorder)
    // Bottom Border
    let bottomBorderGeometry = new THREE.CubeGeometry(40, 10, 50)
    let bottomBorder = new Physijs.BoxMesh(bottomBorderGeometry, dark_woodMaterial, 0)
    bottomBorder.position.set(115, -155, 50)
    scene.add(bottomBorder)
    // Separator
    let separatorGeometry = new THREE.CubeGeometry(10, 230, 50)
    let separator = new Physijs.BoxMesh(separatorGeometry, dark_woodMaterial, 0)
    separator.position.set(100, -35, 50)
    scene.add(separator)

    // TopLeftAngle
    let angleTLGeometry = new THREE.CubeGeometry(10, 65, 50)
    let angleTL = new Physijs.BoxMesh(angleTLGeometry, dark_woodMaterial, 0)
    angleTL.position.set(-75, 125, 50)
    angleTL.rotation.z = Math.PI / -4
    scene.add(angleTL)
    // TopRightAngle
    let angleTRGeometry = new THREE.CubeGeometry(10, 65, 50)
    let angleTR = new Physijs.BoxMesh(angleTRGeometry, dark_woodMaterial, 0)
    angleTR.position.set(105, 125, 50)
    angleTR.rotation.z = Math.PI / 4
    scene.add(angleTR)

    // BottomLeftAngle
    let angleBLGeometry = new THREE.CubeGeometry(10, 60, 50)
    let angleBL = new Physijs.BoxMesh(angleBLGeometry, dark_woodMaterial, 0)
    angleBL.position.set(75, -102, 50)
    angleBL.rotation.z = (Math.PI / -4) - 0.2
    scene.add(angleBL)
    // BottomRightAngle
    let angleBRGeometry = new THREE.CubeGeometry(10, 60, 50)
    let angleBR = new Physijs.BoxMesh(angleBRGeometry, dark_woodMaterial, 0)
    angleBR.position.set(-75, -102, 50)
    angleBR.rotation.z = (Math.PI / 4) + 0.2
    scene.add(angleBR)

    // Cylinder Top Left
    let cylTLGeometry = new THREE.CylinderGeometry(20, 20, 35, 12)
    let cylTL = new Physijs.CylinderMesh(cylTLGeometry, glitterMaterial, 0)
    cylTL.position.set(-50, 50, 50)
    cylTL.rotation.x = Math.PI / 2
    cylTL.castShadow = true
    scene.add(cylTL)
    // Cylinder Top Right
    let cylTRGeometry = new THREE.CylinderGeometry(20, 20, 35, 12)
    let cylTR = new Physijs.CylinderMesh(cylTRGeometry, glitterMaterial, 0)
    cylTR.position.set(50, 50, 50)
    cylTR.rotation.x = Math.PI / 2
    cylTR.castShadow = true
    scene.add(cylTR)
    // Cylinder Bottom
    let cylBGeometry = new THREE.CylinderGeometry(20, 20, 35, 12)
    let cylB = new Physijs.CylinderMesh(cylBGeometry, glitterMaterial, 0)
    cylB.position.set(0, -30, 50)
    cylB.rotation.x = Math.PI / 2
    cylB.castShadow = true
    scene.add(cylB)

    let interactiveMaterial = new THREE.MeshLambertMaterial({
      color: 0xc0c0ff
    })

    // Left Bat
    let batLGeometry = new THREE.CubeGeometry(40, 10, 50)
    let batL = new Physijs.BoxMesh(batLGeometry, silverMaterial, 10)
    batL.position.set(-30, -130, 50)
    batL.rotation.z = (5 * Math.PI) / 6
    scene.add(batL)
    let batLConstraint = new Physijs.DOFConstraint(batL,{x:-40, y:-125,z:50})
    scene.addConstraint(batLConstraint)
    batLConstraint.setAngularLowerLimit({x: -50, y: 0, z: 0});
    batLConstraint.setAngularUpperLimit({x: 50, y: 0, z: 0});
    // Right Bat
    let batRGeometry = new THREE.CubeGeometry(40, 10, 50)
    let batR = new Physijs.BoxMesh(batRGeometry, silverMaterial, 10)
    batR.position.set(30, -130, 50)
    batR.rotation.z = Math.PI / 6
    scene.add(batR)
    let batRConstraint = new Physijs.DOFConstraint(batR,{x:40, y:-125, z:50})
    scene.addConstraint(batRConstraint)
    batRConstraint.setAngularLowerLimit({x: -50, y: 0, z: 0});
    batRConstraint.setAngularUpperLimit({x: 50, y: 0, z: 0});

    // Launcher
    let launcherGeometry = new THREE.CylinderGeometry(9, 9, 50)
    let launcher = new Physijs.CylinderMesh(launcherGeometry, silverMaterial, 1)
    launcher.position.set(112.5, -124, 50)
    launcher.name = 'launcher'
    scene.add(launcher)
    let launcherConstraint = new Physijs.SliderConstraint(
        launcher,
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, Math.PI/2)
    )
    scene.addConstraint(launcherConstraint)
    launcherConstraint.setLimits(-100, 100, 0, 0)
    launcherConstraint.setRestitution(0, 0)

    document.addEventListener('keypress', e => {
      if (e.key == 's') {
        batLConstraint.configureAngularMotor(2, 1, 0, -800, 1500)
        batLConstraint.enableAngularMotor(2)
      }
      if (e.key == 'l') {
        batRConstraint.configureAngularMotor(2, 1, 0, 800, 1500)
        batRConstraint.enableAngularMotor(2)
        }
      if (e.key == ' ' && launcher.position.y > -150) {
        launcherConstraint.enableLinearMotor(500, 1000)
      }
    })
    document.addEventListener('keyup', e => {
      if (e.key == 's') {
        batLConstraint.disableAngularMotor(2)
      }
      if (e.key == 'l') {
        batRConstraint.disableAngularMotor(2)
      }
      if (e.key == ' ') {
        launcherConstraint.disableLinearMotor()
      }
    })

    // scene.add(board)

    // Ball
    let ballGeometry = new THREE.SphereGeometry(9, 32, 32)
    let ball = new Physijs.SphereMesh(ballGeometry, glitterMaterial, 1)
    ball.position.set(115, -50, 50)
    ball.collisions = 0
    ball.name = 'baballe'
    ball.castShadow = true
    scene.add(ball)

    ball.addEventListener('collision', function (other_object, relative_velocity, relative_rotation, contact_normal) {
      document.getElementById('audio').play()
    });
    scene.add(background)

    // Camera
    let camera = new THREE.PerspectiveCamera(45, wWidth / wHeight, 1, 10000)
    camera.position.y = -150
    camera.position.z = 500
    camera.rotation.x = Math.PI / 10
    scene.add(camera)

    // Light
    let light = new THREE.DirectionalLight(0xFFFFFF);
    light.position.set(-50, -50, 115);
    light.target.position.copy(scene.position);
    light.castShadow = true;
    light.shadow.camera.left = -60;
    light.shadow.camera.top = -60;
    light.shadow.camera.right = 60;
    light.shadow.camera.bottom = 60;
    light.shadow.camera.near = 20;
    light.shadow.camera.far = 200;
    light.shadow.bias = -.0001
    light.shadow.mapSize.width = light.shadow.mapSize.height = 2048;
    // light.shadowDarkness = .7;
    scene.add(light);

    let render = function () {
      scene.simulate(undefined, 2)
      requestAnimationFrame(render)
      cylTR.rotation.y = -(Date.now() * 0.001)
      cylTL.rotation.y = Date.now() * 0.001
      cylB.rotation.y = Date.now() * 0.001

      renderer.render(scene, camera)
    }

    render()
  </script>

</body>

</html>